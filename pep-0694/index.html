
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 694 – Upload 2.0 API for Python Package Repositories | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0694/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta name="description" content="Python Enhancement Proposals (PEPs)">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 694</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 694 – Upload 2.0 API for Python Package Repositories</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Donald Stufft &lt;donald&#32;&#97;t&#32;stufft.io&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/pep-694-upload-2-0-api-for-python-package-repositories/16879">Discourse thread</a></dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Topic<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="../topic/packaging/">Packaging</a></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">11-Jun-2022</dd>
<dt class="field-odd">Post-History<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-694-upload-2-0-api-for-python-package-repositories/16879" title="Discourse thread">27-Jun-2022</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#status-quo">Status Quo</a><ul>
<li><a class="reference internal" href="#endpoint">Endpoint</a></li>
<li><a class="reference internal" href="#encoding">Encoding</a></li>
<li><a class="reference internal" href="#content">Content</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#versioning">Versioning</a></li>
<li><a class="reference internal" href="#endpoints">Endpoints</a><ul>
<li><a class="reference internal" href="#create-an-upload-session">Create an Upload Session</a></li>
<li><a class="reference internal" href="#upload-each-file">Upload Each File</a><ul>
<li><a class="reference internal" href="#upload-data">Upload Data</a></li>
<li><a class="reference internal" href="#resume-upload">Resume Upload</a></li>
<li><a class="reference internal" href="#canceling-an-in-progress-upload">Canceling an In Progress Upload</a></li>
<li><a class="reference internal" href="#delete-an-uploaded-file">Delete an uploaded File</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-status">Session Status</a></li>
<li><a class="reference internal" href="#session-cancellation">Session Cancellation</a></li>
<li><a class="reference internal" href="#session-completion">Session Completion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#errors">Errors</a></li>
<li><a class="reference internal" href="#content-types">Content-Types</a></li>
<li><a class="reference internal" href="#version-format-selection">Version + Format Selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#does-this-mean-pypi-is-planning-to-drop-support-for-the-existing-upload-api">Does this mean PyPI is planning to drop support for the existing upload API?</a></li>
<li><a class="reference internal" href="#is-this-resumable-upload-protocol-based-on-anything">Is this Resumable Upload protocol based on anything?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-questions">Open Questions</a><ul>
<li><a class="reference internal" href="#multipart-uploads-vs-tus">Multipart Uploads vs tus</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>There is currently no standardized API for uploading files to a Python package
repository such as PyPI. Instead, everyone has been forced to reverse engineer
the non-standard API from PyPI.</p>
<p>That API, while functional, leaks a lot of implementation details of the original
PyPI code base, which have now had to have been faithfully replicated in the new
code base, and alternative implementations.</p>
<p>Beyond the above, there are a number of major issues with the current API:</p>
<ul class="simple">
<li>It is a fully synchronous API, which means that we’re forced to have a single
request being held open for potentially a long time, both for the upload itself,
and then while the repository processes the uploaded file to determine success
or failure.</li>
<li>It does not support any mechanism for resuming an upload, with the largest file
size on PyPI being just under 1GB in size, that’s a lot of wasted bandwidth if
a large file has a network blip towards the end of an upload.</li>
<li>It treats a single file as the atomic unit of operation, which can be problematic
when a release might have multiple binary wheels which can cause people to get
different versions while the files are uploading, and if the sdist happens to
not go last, possibly some hard to build packages are attempting to be built
from source.</li>
<li>It has very limited support for communicating back to the user, with no support
for multiple errors, warnings, deprecations, etc. It is limited entirely to the
HTTP status code and reason phrase, of which the reason phrase has been
deprecated since HTTP/2 (<span class="target" id="index-0"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7540.html#section-8.1.2.4"><strong>RFC 7540</strong></a>).</li>
<li>The metadata for a release/file is submitted alongside the file, however this
metadata is famously unreliable, and most installers instead choose to download
the entire file and read that in part due to that unreliability.</li>
<li>There is no mechanism for allowing a repository to do any sort of sanity
checks before bandwidth starts getting expended on an upload, whereas a lot
of the cases of invalid metadata or incorrect permissions could be checked
prior to upload.</li>
<li>It has no support for “staging” a draft release prior to publishing it to the
repository.</li>
<li>It has no support for creating new projects, without uploading a file.</li>
</ul>
<p>This PEP proposes a new API for uploads, and deprecates the existing non standard
API.</p>
</section>
<section id="status-quo">
<h2><a class="toc-backref" href="#status-quo" role="doc-backlink">Status Quo</a></h2>
<p>This does not attempt to be a fully exhaustive documentation of the current API, but
give a high level overview of the existing API.</p>
<section id="endpoint">
<h3><a class="toc-backref" href="#endpoint" role="doc-backlink">Endpoint</a></h3>
<p>The existing upload API (and the now removed register API) lives at an url, currently
<code class="docutils literal notranslate"><span class="pre">https://upload.pypi.org/legacy/</span></code>, and to communicate which specific API you want
to call, you add a <code class="docutils literal notranslate"><span class="pre">:action</span></code> url parameter with a value of <code class="docutils literal notranslate"><span class="pre">file_upload</span></code>. The values
of <code class="docutils literal notranslate"><span class="pre">submit</span></code>, <code class="docutils literal notranslate"><span class="pre">submit_pkg_info</span></code>, and <code class="docutils literal notranslate"><span class="pre">doc_upload</span></code> also used to be supported, but
no longer are.</p>
<p>It also has a <code class="docutils literal notranslate"><span class="pre">protocol_version</span></code> parameter, in theory to allow new versions of the
API to be written, but in practice that has never happened, and the value is always
<code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>So in practice, on PyPI, the endpoint is
<code class="docutils literal notranslate"><span class="pre">https://upload.pypi.org/legacy/?:action=file_upload&amp;protocol_version=1</span></code>.</p>
</section>
<section id="encoding">
<h3><a class="toc-backref" href="#encoding" role="doc-backlink">Encoding</a></h3>
<p>The data to be submitted is submitted as a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request with the content type
of <code class="docutils literal notranslate"><span class="pre">multipart/form-data</span></code>. This is due to the historical nature, that this API
was not actually designed as an API, but rather was a form on the initial PyPI
implementation, then client code was written to programmatically submit that form.</p>
</section>
<section id="content">
<h3><a class="toc-backref" href="#content" role="doc-backlink">Content</a></h3>
<p>Roughly speaking, the metadata contained within the package is submitted as parts
where the content-disposition is <code class="docutils literal notranslate"><span class="pre">form-data</span></code>, and the name is the name of the
field. The names of these various pieces of metadata are not documented, and they
sometimes, but not always match the names used in the <code class="docutils literal notranslate"><span class="pre">METADATA</span></code> files. The casing
rarely matches though, but overall the <code class="docutils literal notranslate"><span class="pre">METADATA</span></code> to <code class="docutils literal notranslate"><span class="pre">form-data</span></code> conversion is
extremely inconsistent.</p>
<p>The file itself is then sent as a <code class="docutils literal notranslate"><span class="pre">application/octet-stream</span></code> part with the name
of <code class="docutils literal notranslate"><span class="pre">content</span></code>, and if there is a PGP signature attached, then it will be included
as a <code class="docutils literal notranslate"><span class="pre">application/octet-stream</span></code> part with the name of <code class="docutils literal notranslate"><span class="pre">gpg_signature</span></code>.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>This PEP traces the root cause of most of the issues with the existing API to be
roughly two things:</p>
<ul class="simple">
<li>The metadata is submitted alongside the file, rather than being parsed from the
file itself.<ul>
<li>This is actually fine if used as a pre-check, but it should be validated
against the actual <code class="docutils literal notranslate"><span class="pre">METADATA</span></code> or similar files within the distribution.</li>
</ul>
</li>
<li>It supports a single request, using nothing but form data, that either succeeds
or fails, and everything is done and contained within that single request.</li>
</ul>
<p>We then propose a multi-request workflow, that essentially boils down to:</p>
<ol class="arabic simple">
<li>Initiate an upload session.</li>
<li>Upload the file(s) as part of the upload session.</li>
<li>Complete the upload session.</li>
<li>(Optional) Check the status of an upload session.</li>
</ol>
<p>All URLs described here will be relative to the root endpoint, which may be
located anywhere within the url structure of a domain. So it could be at
<code class="docutils literal notranslate"><span class="pre">https://upload.example.com/</span></code>, or <code class="docutils literal notranslate"><span class="pre">https://example.com/upload/</span></code>.</p>
<section id="versioning">
<h3><a class="toc-backref" href="#versioning" role="doc-backlink">Versioning</a></h3>
<p>This PEP uses the same <code class="docutils literal notranslate"><span class="pre">MAJOR.MINOR</span></code> versioning system as used in <a class="pep reference internal" href="../pep-0691/" title="PEP 691 – JSON-based Simple API for Python Package Indexes">PEP 691</a>,
but it is otherwise independently versioned. The existing API is considered by
this spec to be version <code class="docutils literal notranslate"><span class="pre">1.0</span></code>, but it otherwise does not attempt to modify
that API in any way.</p>
</section>
<section id="endpoints">
<h3><a class="toc-backref" href="#endpoints" role="doc-backlink">Endpoints</a></h3>
<section id="create-an-upload-session">
<h4><a class="toc-backref" href="#create-an-upload-session" role="doc-backlink">Create an Upload Session</a></h4>
<p>To create a new upload session, you can send a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request to <code class="docutils literal notranslate"><span class="pre">/</span></code>,
with a payload that looks like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;api-version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2.0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1.0&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This currently has three keys, <code class="docutils literal notranslate"><span class="pre">meta</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, and <code class="docutils literal notranslate"><span class="pre">version</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">meta</span></code> key is included in all payloads, and it describes information about the
payload itself.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> key is the name of the project that this session is attempting to
add files to.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">version</span></code> key is the version of the project that this session is attepmting to
add files to.</p>
<p>If creating the session was successful, then the server must return a response
that looks like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;api-version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2.0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;urls&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;upload&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;draft&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;publish&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;valid-for&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">604800</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;status&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;pending&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;files&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{},</span>
<span class="w">  </span><span class="nt">&quot;notices&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="s2">&quot;a notice to display to the user&quot;</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Besides the <code class="docutils literal notranslate"><span class="pre">meta</span></code> key, this response has five keys, <code class="docutils literal notranslate"><span class="pre">urls</span></code>, <code class="docutils literal notranslate"><span class="pre">valid-for</span></code>,
<code class="docutils literal notranslate"><span class="pre">status</span></code>, <code class="docutils literal notranslate"><span class="pre">files</span></code>, and <code class="docutils literal notranslate"><span class="pre">notices</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">urls</span></code> key is a dictionary mapping identifiers to related URLs to this
session.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">valid-for</span></code> key is an integer representing how long, in seconds, until the
server itself will expire this session (and thus all of the URLs contained in it).
The session <strong>SHOULD</strong> live at least this much longer unless the client itself
has canceled the session. Servers <strong>MAY</strong> choose to <em>increase</em> this time, but should
never <em>decrease</em> it, except naturally through the passage of time.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">status</span></code> key is a string that contains one of <code class="docutils literal notranslate"><span class="pre">pending</span></code>, <code class="docutils literal notranslate"><span class="pre">published</span></code>,
<code class="docutils literal notranslate"><span class="pre">errored</span></code>, or <code class="docutils literal notranslate"><span class="pre">canceled</span></code>, this string represents the overall status of
the session.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">files</span></code> key is a mapping containing the filenames that have been uploaded
to this session, to a mapping containing details about each file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">notices</span></code> key is an optional key that points to an array of notices that
the server wishes to communicate to the end user that are not specific to any
one file.</p>
<p>For each filename in <code class="docutils literal notranslate"><span class="pre">files</span></code> the mapping has three keys, <code class="docutils literal notranslate"><span class="pre">status</span></code>, <code class="docutils literal notranslate"><span class="pre">url</span></code>,
and <code class="docutils literal notranslate"><span class="pre">notices</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">status</span></code> key is the same as the top level <code class="docutils literal notranslate"><span class="pre">status</span></code> key, except that it
indicates the status of a specific file.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">url</span></code> key is the <em>absolute</em> URL that the client should upload that specific
file to (or use to delete that file).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">notices</span></code> key is an optional key, that is an array of notices that the server
wishes to communicate to the end user that are specific to this file.</p>
<p>The required response code to a successful creation of the session is a
<code class="docutils literal notranslate"><span class="pre">201</span> <span class="pre">Created</span></code> response and it <strong>MUST</strong> include a <code class="docutils literal notranslate"><span class="pre">Location</span></code> header that is the
URL for this session, which may be used to check its status or cancel it.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">urls</span></code> key, there are currently three keys that may appear:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">upload</span></code> key, which is the upload endpoint for this session to initiate
a file upload.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">draft</span></code> key, which is the repository URL that these files are available at
prior to publishing.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">publish</span></code> key, which is the endpoint to trigger publishing the session.</p>
<p>In addition to the above, if a second session is created for the same name+version
pair, then the upload server <strong>MUST</strong> return the already existing session rather
than creating a new, empty one.</p>
</section>
<section id="upload-each-file">
<h4><a class="toc-backref" href="#upload-each-file" role="doc-backlink">Upload Each File</a></h4>
<p>Once you have initiated an upload session for one or more files, then you have
to actually upload each of those files.</p>
<p>There is no set endpoint for actually uploading the file, that is given to the
client by the server as part of the creation of the upload session, and clients
<strong>MUST NOT</strong> assume that there is any commonality to what those URLs look like from
one session to the next.</p>
<p>To initiate a file upload, a client sends a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request to the upload URL
in the session, with a request body that looks like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;api-version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2.0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;filename&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;foo-1.0.tar.gz&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;size&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;hashes&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;sha256&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;blake2b&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;metadata&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Besides the standard <code class="docutils literal notranslate"><span class="pre">meta</span></code> key, this currently has 4 keys:</p>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: The filename of the file being uploaded.</li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: The size, in bytes, of the file that is being uploaded.</li>
<li><code class="docutils literal notranslate"><span class="pre">hashes</span></code>: A mapping of hash names to hex encoded digests, each of these digests
are the digests of that file, when hashed by the hash identified in the name.<p>By default, any hash algorithm available via <a class="reference external" href="https://docs.python.org/3/library/hashlib.html">hashlib</a> (specifically any that can
be passed to <code class="docutils literal notranslate"><span class="pre">hashlib.new()</span></code> and do not require additional parameters) can
be used as a key for the hashes dictionary. At least one secure algorithm from
<code class="docutils literal notranslate"><span class="pre">hashlib.algorithms_guaranteed</span></code> <strong>MUST</strong> always be included. At the time
of this PEP, <code class="docutils literal notranslate"><span class="pre">sha256</span></code> specifically is recommended.</p>
<p>Multiple hashes may be passed at a time, but all hashes must be valid for the
file.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">metadata</span></code>: An optional key that is a string containing the file’s
<a class="reference external" href="https://packaging.python.org/en/latest/specifications/core-metadata/">core metadata</a>.</li>
</ul>
<p>Servers <strong>MAY</strong> use the data provided in this response to do some sanity checking
prior to allowing the file to be uploaded, which may include but is not limited
to:</p>
<ul class="simple">
<li>Checking if the <code class="docutils literal notranslate"><span class="pre">filename</span></code> already exists.</li>
<li>Checking if the <code class="docutils literal notranslate"><span class="pre">size</span></code> would invalidate some quota.</li>
<li>Checking if the contents of the <code class="docutils literal notranslate"><span class="pre">metadata</span></code>, if provided, are valid.</li>
</ul>
<p>If the server determines that the client should attempt the upload, it will return
a <code class="docutils literal notranslate"><span class="pre">201</span> <span class="pre">Created</span></code> response, with an empty body, and a <code class="docutils literal notranslate"><span class="pre">Location</span></code> header pointing
to the URL that the file itself should be uploaded to.</p>
<p>At this point, the status of the session should show the filename, with the above url
included in it.</p>
<section id="upload-data">
<h5><a class="toc-backref" href="#upload-data" role="doc-backlink">Upload Data</a></h5>
<p>To upload the file, a client has two choices, they may upload the file as either
a single chunk, or as multiple chunks. Either option is acceptable, but it is
recommended that most clients should choose to upload each file as a single chunk
as that requires fewer requests and typically has better performance.</p>
<p>However for particularly large files, uploading within a single request may result
in timeouts, so larger files may need to be uploaded in multiple chunks.</p>
<p>In either case, the client must generate a unique token (or nonce) for each upload
attempt for a file, and <strong>MUST</strong> include that token in each request in the <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code>
header. The <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code> is a binary blob encoded using base64 surrounded by
a <code class="docutils literal notranslate"><span class="pre">:</span></code> on either side. Clients <strong>SHOULD</strong> use at least 32 bytes of cryptographically
random data. You can generate it using the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">secrets</span>

<span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">secrets</span><span class="o">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
</pre></div>
</div>
<p>The one time that it is permissible to omit the <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code> from an upload
request is when a client wishes to opt out of the resumable or chunked file upload
feature completely. In that case, they <strong>MAY</strong> omit the <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code>, and the
file must be successfully uploaded in a single HTTP request, and if it fails, the
entire file must be resent in another single HTTP request.</p>
<p>To upload in a single chunk, a client sends a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request to the URL from the
session response for that filename. The client <strong>MUST</strong> include a <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code>
header that is equal to the size of the file in bytes, and this <strong>MUST</strong> match the
size given in the original session creation.</p>
<p>As an example, if uploading a 100,000 byte file, you would send headers like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Length</span><span class="p">:</span> <span class="mi">100000</span>
<span class="n">Upload</span><span class="o">-</span><span class="n">Token</span><span class="p">:</span> <span class="p">:</span><span class="n">nYuc7Lg2</span><span class="o">/</span><span class="n">Lv9S4EYoT9WE6nwFZgN</span><span class="o">/</span><span class="n">TcUXyk9wtwoABg</span><span class="o">=</span><span class="p">:</span>
</pre></div>
</div>
<p>If the upload completes successfully, the server <strong>MUST</strong> respond with a
<code class="docutils literal notranslate"><span class="pre">201</span> <span class="pre">Created</span></code> status. At this point this file <strong>MUST</strong> not be present in the
repository, but merely staged until the upload session has completed.</p>
<p>To upload in multiple chunks, a client sends multiple <code class="docutils literal notranslate"><span class="pre">POST</span></code> requests to the same
URL as before, one for each chunk.</p>
<p>This time however, the <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> is equal to the size, in bytes, of the
chunk that they are sending. In addition, the client <strong>MUST</strong> include a
<code class="docutils literal notranslate"><span class="pre">Upload-Offset</span></code> header which indicates a byte offset that the content included
in this request starts at and a <code class="docutils literal notranslate"><span class="pre">Upload-Incomplete</span></code> header set to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>As an example, if uploading a 100,000 byte file in 1000 byte chunks, and this chunk
represents bytes 1001 through 2000, you would send headers like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Length</span><span class="p">:</span> <span class="mi">1000</span>
<span class="n">Upload</span><span class="o">-</span><span class="n">Token</span><span class="p">:</span> <span class="p">:</span><span class="n">nYuc7Lg2</span><span class="o">/</span><span class="n">Lv9S4EYoT9WE6nwFZgN</span><span class="o">/</span><span class="n">TcUXyk9wtwoABg</span><span class="o">=</span><span class="p">:</span>
<span class="n">Upload</span><span class="o">-</span><span class="n">Offset</span><span class="p">:</span> <span class="mi">1001</span>
<span class="n">Upload</span><span class="o">-</span><span class="n">Incomplete</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<p>However, the <strong>final</strong> chunk of data omits the <code class="docutils literal notranslate"><span class="pre">Upload-Incomplete</span></code> header, since
at that point the upload is no longer incomplete.</p>
<p>For each successful chunk, the server <strong>MUST</strong> respond with a <code class="docutils literal notranslate"><span class="pre">202</span> <span class="pre">Accepted</span></code>
header, except for the final chunk, which <strong>MUST</strong> be a <code class="docutils literal notranslate"><span class="pre">201</span> <span class="pre">Created</span></code>.</p>
<p>The following constraints are placed on uploads regardless of whether they are
single chunk or multiple chunks:</p>
<ul class="simple">
<li>A client <strong>MUST NOT</strong> perform multiple <code class="docutils literal notranslate"><span class="pre">POST</span></code> requests in parallel for the
same file to avoid race conditions and data loss or corruption. The server
<strong>MAY</strong> terminate any ongoing <code class="docutils literal notranslate"><span class="pre">POST</span></code> request that utilizes the same
<code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code>.</li>
<li>If the offset provided in <code class="docutils literal notranslate"><span class="pre">Upload-Offset</span></code> is not <code class="docutils literal notranslate"><span class="pre">0</span></code> or the next chunk
in an incomplete upload, then the server <strong>MUST</strong> respond with a 409 Conflict.</li>
<li>Once an upload has started with a specific token, you may not use another token
for that file without deleting the in progress upload.</li>
<li>Once a file has uploaded successfully, you may initiate another upload for
that file, and doing so will replace that file.</li>
</ul>
</section>
<section id="resume-upload">
<h5><a class="toc-backref" href="#resume-upload" role="doc-backlink">Resume Upload</a></h5>
<p>To resume an upload, you first have to know how much of the data the server has
already received, regardless of if you were originally uploading the file as
a single chunk, or in multiple chunks.</p>
<p>To get the status of an individual upload, a client can make a <code class="docutils literal notranslate"><span class="pre">HEAD</span></code> request
with their existing <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code> to the same URL they were uploading to.</p>
<p>The server <strong>MUST</strong> respond back with a <code class="docutils literal notranslate"><span class="pre">204</span> <span class="pre">No</span> <span class="pre">Content</span></code> response, with an
<code class="docutils literal notranslate"><span class="pre">Upload-Offset</span></code> header that indicates what offset the client should continue
uploading from. If the server has not received any data, then this would be <code class="docutils literal notranslate"><span class="pre">0</span></code>,
if it has received 1007 bytes then it would be <code class="docutils literal notranslate"><span class="pre">1007</span></code>.</p>
<p>Once the client has retrieved the offset that they need to start from, they can
upload the rest of the file as described above, either in a single request
containing all of the remaining data or in multiple chunks.</p>
</section>
<section id="canceling-an-in-progress-upload">
<h5><a class="toc-backref" href="#canceling-an-in-progress-upload" role="doc-backlink">Canceling an In Progress Upload</a></h5>
<p>If a client wishes to cancel an upload of a specific file, for instance because
they need to upload a different file, they may do so by issuing a <code class="docutils literal notranslate"><span class="pre">DELETE</span></code>
request to the file upload URL with the <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code> used to upload the
file in the first place.</p>
<p>A successful cancellation request <strong>MUST</strong> response with a <code class="docutils literal notranslate"><span class="pre">204</span> <span class="pre">No</span> <span class="pre">Content</span></code>.</p>
</section>
<section id="delete-an-uploaded-file">
<h5><a class="toc-backref" href="#delete-an-uploaded-file" role="doc-backlink">Delete an uploaded File</a></h5>
<p>Already uploaded files may be deleted by issuing a <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> request to the file
upload URL without the <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code>.</p>
<p>A successful deletion request <strong>MUST</strong> response with a <code class="docutils literal notranslate"><span class="pre">204</span> <span class="pre">No</span> <span class="pre">Content</span></code>.</p>
</section>
</section>
<section id="session-status">
<h4><a class="toc-backref" href="#session-status" role="doc-backlink">Session Status</a></h4>
<p>Similarly to file upload, the session URL is provided in the response to
creating the upload session, and clients <strong>MUST NOT</strong> assume that there is any
commonality to what those URLs look like from one session to the next.</p>
<p>To check the status of a session, clients issue a <code class="docutils literal notranslate"><span class="pre">GET</span></code> request to the
session URL, to which the server will respond with the same response that
they got when they initially created the upload session, except with any
changes to <code class="docutils literal notranslate"><span class="pre">status</span></code>, <code class="docutils literal notranslate"><span class="pre">valid-for</span></code>, or updated <code class="docutils literal notranslate"><span class="pre">files</span></code> reflected.</p>
</section>
<section id="session-cancellation">
<h4><a class="toc-backref" href="#session-cancellation" role="doc-backlink">Session Cancellation</a></h4>
<p>To cancel an upload session, a client issues a <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> request to the
same session URL as before. At which point the server marks the session as
canceled, <strong>MAY</strong> purge any data that was uploaded as part of that session,
and future attempts to access that session URL or any of the file upload URLs
<strong>MAY</strong> return a <code class="docutils literal notranslate"><span class="pre">404</span> <span class="pre">Not</span> <span class="pre">Found</span></code>.</p>
<p>To prevent a lot of dangling sessions, servers may also choose to cancel a
session on their own accord. It is recommended that servers expunge their
sessions after no less than a week, but each server may choose their own
schedule.</p>
</section>
<section id="session-completion">
<h4><a class="toc-backref" href="#session-completion" role="doc-backlink">Session Completion</a></h4>
<p>To complete a session, and publish the files that have been included in it,
a client <strong>MUST</strong> send a <code class="docutils literal notranslate"><span class="pre">POST</span></code> request to the <code class="docutils literal notranslate"><span class="pre">publish</span></code> url in the
session status payload.</p>
<p>If the server is able to immediately complete the session, it may do so
and return a <code class="docutils literal notranslate"><span class="pre">201</span> <span class="pre">Created</span></code> response. If it is unable to immediately
complete the session (for instance, if it needs to do processing that may
take longer than reasonable in a single HTTP request), then it may return
a <code class="docutils literal notranslate"><span class="pre">202</span> <span class="pre">Accepted</span></code> response.</p>
<p>In either case, the server should include a <code class="docutils literal notranslate"><span class="pre">Location</span></code> header pointing
back to the session status url, and if the server returned a <code class="docutils literal notranslate"><span class="pre">202</span> <span class="pre">Accepted</span></code>,
the client may poll that URL to watch for the status to change.</p>
</section>
</section>
<section id="errors">
<h3><a class="toc-backref" href="#errors" role="doc-backlink">Errors</a></h3>
<p>All Error responses that contain a body will have a body that looks like:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;meta&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;api-version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2.0&quot;</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;message&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;errors&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;source&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;message&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Besides the standard <code class="docutils literal notranslate"><span class="pre">meta</span></code> key, this has two top level keys, <code class="docutils literal notranslate"><span class="pre">message</span></code>
and <code class="docutils literal notranslate"><span class="pre">errors</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">message</span></code> key is a singular message that encapsulates all errors that
may have happened on this request.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">errors</span></code> key is an array of specific errors, each of which contains
a <code class="docutils literal notranslate"><span class="pre">source</span></code> key, which is a string that indicates what the source of the
error is, and a <code class="docutils literal notranslate"><span class="pre">messasge</span></code> key for that specific error.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">message</span></code> and <code class="docutils literal notranslate"><span class="pre">source</span></code> strings do not have any specific meaning, and
are intended for human interpretation to figure out what the underlying issue
was.</p>
</section>
<section id="content-types">
<h3><a class="toc-backref" href="#content-types" role="doc-backlink">Content-Types</a></h3>
<p>Like <a class="pep reference internal" href="../pep-0691/" title="PEP 691 – JSON-based Simple API for Python Package Indexes">PEP 691</a>, this PEP proposes that all requests and responses from the
Upload API will have a standard content type that describes what the content
is, what version of the API it represents, and what serialization format has
been used.</p>
<p>The structure of this content type will be:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>application/vnd.pypi.upload.$version+format
</pre></div>
</div>
<p>Since only major versions should be disruptive to systems attempting to
understand one of these API content bodies, only the major version will be
included in the content type, and will be prefixed with a <code class="docutils literal notranslate"><span class="pre">v</span></code> to clarify
that it is a version number.</p>
<p>Unlike <a class="pep reference internal" href="../pep-0691/" title="PEP 691 – JSON-based Simple API for Python Package Indexes">PEP 691</a>, this PEP does not change the existing <code class="docutils literal notranslate"><span class="pre">1.0</span></code> API in any
way, so servers will be required to host the new API described in this PEP at
a different endpoint than the existing upload API.</p>
<p>Which means that for the new 2.0 API, the content types would be:</p>
<ul class="simple">
<li><strong>JSON:</strong> <code class="docutils literal notranslate"><span class="pre">application/vnd.pypi.upload.v2+json</span></code></li>
</ul>
<p>In addition to the above, a special “meta” version is supported named <code class="docutils literal notranslate"><span class="pre">latest</span></code>,
whose purpose is to allow clients to request the absolute latest version, without
having to know ahead of time what that version is. It is recommended however,
that clients be explicit about what versions they support.</p>
<p>These content types <strong>DO NOT</strong> apply to the file uploads themselves, only to the
other API requests/responses in the upload API. The files themselves should use
the <code class="docutils literal notranslate"><span class="pre">application/octet-stream</span></code> content-type.</p>
</section>
<section id="version-format-selection">
<h3><a class="toc-backref" href="#version-format-selection" role="doc-backlink">Version + Format Selection</a></h3>
<p>Again similar to <a class="pep reference internal" href="../pep-0691/" title="PEP 691 – JSON-based Simple API for Python Package Indexes">PEP 691</a>, this PEP standardizes on using server-driven
content negotiation to allow clients to request different versions or
serialization formats, which includes the <code class="docutils literal notranslate"><span class="pre">format</span></code> url parameter.</p>
<p>Since this PEP expects the existing legacy <code class="docutils literal notranslate"><span class="pre">1.0</span></code> upload API to exist at a
different endpoint, and it currently only provides for JSON serialization, this
mechanism is not particularly useful, and clients only have a single version and
serialization they can request. However clients <strong>SHOULD</strong> be setup to handle
content negotiation gracefully in the case that additional formats or versions
are added in the future.</p>
</section>
</section>
<section id="faq">
<h2><a class="toc-backref" href="#faq" role="doc-backlink">FAQ</a></h2>
<section id="does-this-mean-pypi-is-planning-to-drop-support-for-the-existing-upload-api">
<h3><a class="toc-backref" href="#does-this-mean-pypi-is-planning-to-drop-support-for-the-existing-upload-api" role="doc-backlink">Does this mean PyPI is planning to drop support for the existing upload API?</a></h3>
<p>At this time PyPI does not have any specific plans to drop support for the
existing upload API.</p>
<p>Unlike with <a class="pep reference internal" href="../pep-0691/" title="PEP 691 – JSON-based Simple API for Python Package Indexes">PEP 691</a> there are wide benefits to doing so, so it is likely
that we will want to drop support for it at some point in the future, but
until this API is implemented, and receiving broad use it would be premature
to make any plans for actually dropping support for it.</p>
</section>
<section id="is-this-resumable-upload-protocol-based-on-anything">
<h3><a class="toc-backref" href="#is-this-resumable-upload-protocol-based-on-anything" role="doc-backlink">Is this Resumable Upload protocol based on anything?</a></h3>
<p>Yes!</p>
<p>It’s actually the protocol specified in an
<a class="reference external" href="https://datatracker.ietf.org/doc/draft-tus-httpbis-resumable-uploads-protocol/">Active Internet-Draft</a>,
where the authors took what they learned implementing <a class="reference external" href="https://tus.io/">tus</a>
to provide the idea of resumable uploads in a wholly generic, standards based
way.</p>
<p>The only deviation we’ve made from that spec is that we don’t use the
<code class="docutils literal notranslate"><span class="pre">104</span> <span class="pre">Upload</span> <span class="pre">Resumption</span> <span class="pre">Supported</span></code> informational response in the first
<code class="docutils literal notranslate"><span class="pre">POST</span></code> request. This decision was made for a few reasons:</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">104</span> <span class="pre">Upload</span> <span class="pre">Resumption</span> <span class="pre">Supported</span></code> is the only part of that draft
which does not rely entirely on things that are already supported in the
existing standards, since it was adding a new informational status.</li>
<li>Many clients and web frameworks don’t support <code class="docutils literal notranslate"><span class="pre">1xx</span></code> informational
responses in a very good way, if at all, adding it would complicate
implementation for very little benefit.</li>
<li>The purpose of the <code class="docutils literal notranslate"><span class="pre">104</span> <span class="pre">Upload</span> <span class="pre">Resumption</span> <span class="pre">Supported</span></code> support is to allow
clients to determine that an arbitrary endpoint that they’re interacting
with supports resumable uploads. Since this PEP is mandating support for
that in servers, clients can just assume that the server they are
interacting with supports it, which makes using it unneeded.</li>
<li>In theory, if the support for <code class="docutils literal notranslate"><span class="pre">1xx</span></code> responses got resolved and the draft
gets accepted with it in, we can add that in at a later date without
changing the overall flow of the API.</li>
</ul>
<p>There is a risk that the above draft doesn’t get accepted, but even if it
does not, that doesn’t actually affect us. It would just mean that our
support for resumable uploads is an application specific protocol, but is
still wholly standards compliant.</p>
</section>
</section>
<section id="open-questions">
<h2><a class="toc-backref" href="#open-questions" role="doc-backlink">Open Questions</a></h2>
<section id="multipart-uploads-vs-tus">
<h3><a class="toc-backref" href="#multipart-uploads-vs-tus" role="doc-backlink">Multipart Uploads vs tus</a></h3>
<p>This PEP currently bases the actual uploading of files on an internet draft
from tus.io that supports resumable file uploads.</p>
<p>That protocol requires a few things:</p>
<ul class="simple">
<li>That the client selects a secure <code class="docutils literal notranslate"><span class="pre">Upload-Token</span></code> that they use to identify
uploading a single file.</li>
<li>That if clients don’t upload the entire file in one shot, that they have
to submit the chunks serially, and in the correct order, with all but the
final chunk having a <code class="docutils literal notranslate"><span class="pre">Upload-Incomplete:</span> <span class="pre">1</span></code> header.</li>
<li>Resumption of an upload is essentially just querying the server to see how
much data they’ve gotten, then sending the remaining bytes (either as a single
request, or in chunks).</li>
<li>The upload implicitly is completed when the server successfully gets all of
the data from the client.</li>
</ul>
<p>This has one big benefit, that if a client doesn’t care about resuming their
download, the work to support, from a client side, resumable uploads is able
to be completely ignored. They can just <code class="docutils literal notranslate"><span class="pre">POST</span></code> the file to the URL, and if
it doesn’t succeed, they can just <code class="docutils literal notranslate"><span class="pre">POST</span></code> the whole file again.</p>
<p>The other benefit is that even if you do want to support resumption, you can
still just <code class="docutils literal notranslate"><span class="pre">POST</span></code> the file, and unless you <em>need</em> to resume the download,
that’s all you have to do.</p>
<p>Another, possibly theoretical, benefit is that for hashing the uploaded files,
the serial chunks requirement means that the server can maintain hashing state
between requests, update it for each request, then write that file back to
storage. Unfortunately this isn’t actually possible to do with Python’s hashlib,
though there are some libraries like <a class="reference external" href="https://github.com/kislyuk/rehash">Rehash</a>
that implement it, but they don’t support every hash that hashlib does
(specifically not blake2 or sha3 at the time of writing).</p>
<p>We might also need to reconstitute the download for processing anyways to do
things like extract metadata, etc from it, which would make it a moot point.</p>
<p>The downside is that there is no ability to parallelize the upload of a single
file because each chunk has to be submitted serially.</p>
<p>AWS S3 has a similar API (and most blob stores have copied it either wholesale
or something like it) which they call multipart uploading.</p>
<p>The basic flow for a multipart upload is:</p>
<ol class="arabic simple">
<li>Initiate a Multipart Upload to get an Upload ID.</li>
<li>Break your file up into chunks, and upload each one of them individually.</li>
<li>Once all chunks have been uploaded, finalize the upload.
- This is the step where any errors would occur.</li>
</ol>
<p>It does not directly support resuming an upload, but it allows clients to
control the “blast radius” of failure by adjusting the size of each part
they upload, and if any of the parts fail, they only have to resend those
specific parts.</p>
<p>This has a big benefit in that it allows parallelization in uploading files,
allowing clients to maximize their bandwidth using multiple threads to send
the data.</p>
<p>We wouldn’t need an explicit step (1), because our session would implicitly
initiate a multipart upload for each file.</p>
<p>It does have its own downsides:</p>
<ul class="simple">
<li>Clients have to do more work on every request to have something resembling
resumable uploads. They would <em>have</em> to break the file up into multiple parts
rather than just making a single POST request, and only needing to deal
with the complexity if something fails.</li>
<li>Clients that don’t care about resumption at all still have to deal with
the third explicit step, though they could just upload the file all as a
single part.<ul>
<li>S3 works around this by having another API for one shot uploads, but
I’d rather not have two different APIs for uploading the same file.</li>
</ul>
</li>
<li>Verifying hashes gets somewhat more complicated. AWS implements hashing
multipart uploads by hashing each part, then the overall hash is just a
hash of those hashes, not of the content itself. We need to know the
actual hash of the file itself for PyPI, so we would have to reconstitute
the file and read its content and hash it once it’s been fully uploaded,
though we could still use the hash of hashes trick for checksumming the
upload itself.<ul>
<li>See above about whether this is actually a downside in practice, or
if it’s just in theory.</li>
</ul>
</li>
</ul>
<p>I lean towards the tus style resumable uploads as I think they’re simpler
to use and to implement, and the main downside is that we possibly leave
some multi-threaded performance on the table, which I think that I’m
personally fine with?</p>
<p>I guess one additional benefit of the S3 style multi part uploads is that
you don’t have to try and do any sort of protection against parallel uploads,
since they’re just supported. That alone might erase most of the server side
implementation simplification.</p>
</section>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0694.rst">https://github.com/python/peps/blob/main/peps/pep-0694.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0694.rst">2023-09-09 17:39:29 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#status-quo">Status Quo</a><ul>
<li><a class="reference internal" href="#endpoint">Endpoint</a></li>
<li><a class="reference internal" href="#encoding">Encoding</a></li>
<li><a class="reference internal" href="#content">Content</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#versioning">Versioning</a></li>
<li><a class="reference internal" href="#endpoints">Endpoints</a><ul>
<li><a class="reference internal" href="#create-an-upload-session">Create an Upload Session</a></li>
<li><a class="reference internal" href="#upload-each-file">Upload Each File</a><ul>
<li><a class="reference internal" href="#upload-data">Upload Data</a></li>
<li><a class="reference internal" href="#resume-upload">Resume Upload</a></li>
<li><a class="reference internal" href="#canceling-an-in-progress-upload">Canceling an In Progress Upload</a></li>
<li><a class="reference internal" href="#delete-an-uploaded-file">Delete an uploaded File</a></li>
</ul>
</li>
<li><a class="reference internal" href="#session-status">Session Status</a></li>
<li><a class="reference internal" href="#session-cancellation">Session Cancellation</a></li>
<li><a class="reference internal" href="#session-completion">Session Completion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#errors">Errors</a></li>
<li><a class="reference internal" href="#content-types">Content-Types</a></li>
<li><a class="reference internal" href="#version-format-selection">Version + Format Selection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#faq">FAQ</a><ul>
<li><a class="reference internal" href="#does-this-mean-pypi-is-planning-to-drop-support-for-the-existing-upload-api">Does this mean PyPI is planning to drop support for the existing upload API?</a></li>
<li><a class="reference internal" href="#is-this-resumable-upload-protocol-based-on-anything">Is this Resumable Upload protocol based on anything?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-questions">Open Questions</a><ul>
<li><a class="reference internal" href="#multipart-uploads-vs-tus">Multipart Uploads vs tus</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0694.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
</body>
</html>